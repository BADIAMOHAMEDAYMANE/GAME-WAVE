<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SpeedyVerse</title>
  <link rel="icon" href="icon.png">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Press+Start+2P" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">

  <style>
    html {
      height: 100%;
    }

    body {
      background: #222;
      font-family: "Press Start 2P", monospace;
      height: 100%;
      margin: 0;
      overflow: hidden;
    }

    /* UI */
    .topUI {
      position: absolute;
      z-index: 1000;
      /* need this cause clip-path changes stack context */
      transform: translate(-50%, 25px);
      text-shadow: -2px 0 black, 0 2px black, 2px 0 black, 0 -2px black;
      letter-spacing: 2px;
      color: #fff;
      font-size: 17px;
    }

    .topUI::before {
      display: inline-block;
      height: 17px;
      padding: 1px 2px;
      line-height: 19px;
      font-size: 17px;
      background: #fff;
      text-shadow: none;
      font-weight: 900;
      letter-spacing: 0;
      border-radius: 6px;
      margin-right: 30px;
      border: 2px solid #7dd8c9;
    }

    #time {
      left: 13%;
      color: #f4f430;
    }

    #time::before {
      content: "TIME";
      color: #f57214;
    }

    #score {
      left: 45%;
    }

    #score::before {
      content: "SCORE";
      color: #a61a9d;
    }

    #lap {
      left: 88%;
      width: 45%;
    }

    #lap::before {
      content: "LAP";
      color: #0082df;
    }

    #tacho {
      position: absolute;
      text-align: right;
      width: 23%;
      bottom: 5%;
      z-index: 2000;
      color: #e62e13;
      text-shadow: -2px 0 black, 0 2px black, 2px 0 black, 0 -2px black;
      letter-spacing: 2px;
      font-size: 23px;
    }

    #tacho::after {
      content: "km/h";
      color: #fab453;
      font-size: 18px;
      margin-left: 5px;
    }

    /*
  road
*/
    #game {
      width: 100%;
      height: 100%;
      position: relative;
      margin: 0 auto;
      overflow: hidden;
      background: #222;
      user-select: none;
      transition: opacity 10s;
    }

    #road {
      position: absolute;
      width: 100%;
      height: 100%;
      transition: opacity 2s;
      transition-timing-function: steps(8, end);
    }

    #road * {
      position: absolute;
    }

    #hero {
      background-repeat: no-repeat;
      background-position: -110px 0;
      z-index: 2000;
      transform: scale(1.4);
    }

    #cloud {
      background-size: cover;
      width: 100%;
      height: 65%;
      background-repeat: repeat-x;
    }

    /*
  home
*/

    #home {
      position: absolute;
      color: #fff;
      width: 100%;
      height: 100%;

      z-index: 1000;
      /* need this cause clip-path changes stack context */
    }

    #highscore {
      position: absolute;
      width: 100%;
      height: 20%;
      bottom: 0;
      column-count: 3;
      column-fill: auto;
    }

    #highscore * {
      color: #9e95a8;
      margin: 0 0 6px 27px;
    }

    h1 {
      position: absolute;
      left: 50%;
      top: 25%;
      transform: translate(-50%, -50%);
      font-size: 5em;

      background: -webkit-linear-gradient(#25d8b1, #e2bbf0);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    #text {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.2em;
      color: #d9bbf3;
      text-shadow: 0 0 black, 0 2px black, 2px 0 black, 0 0 black;
    }

    .blink {
      animation: blinker 2s steps(4, end) infinite;
    }

    @keyframes blinker {
      50% {
        opacity: 0;
      }
    }

    /* Container for standardization */
    #game-container {
      width: 100%;
      height: 100%;
      position: relative;
      background: #000;
    }

    .top-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
      z-index: 3000;
    }

    .control-btn {
      background: #27272a;
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: #f4f4f5;
      font-weight: 600;
      cursor: pointer;
      font-size: 1.1rem;
      padding: 8px;
      border-radius: 10px;
      transition: all 0.2s ease;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .control-btn:hover {
      background: #38bdf8;
      color: #000;
      transform: scale(1.1);
    }

    #game:fullscreen,
    #game-container:fullscreen {
      width: 100vw !important;
      height: 100vh !important;
      margin: 0 !important;
    }

    /* Light Mode */
    body.light-mode {
      background: #e2e8f0;
    }

    body.light-mode #game-container {
      background: #f1f5f9;
    }

    body.light-mode .topUI {
      color: #1e293b;
      text-shadow: none;
    }

    body.light-mode .control-btn {
      background: #f1f5f9;
      border-color: #cbd5e1;
      color: #1e293b;
    }

    /* Theater Mode (Full Window) */
    #game-container.theater-mode {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 9999;
    }

    #game-container.theater-mode #game {
      width: 100vw !important;
      height: 100vh !important;
    }

    /* Guide */
    #controls {
      color: #868686;
      font-size: 13px;
      line-height: 13px;
      margin: 10px;
      text-align: center;
    }

    #controls>span {
      margin-left: 20px;
    }

    #controls>span>span {
      border: 2px solid #868686;
      border-radius: 5px;
      padding: 7px;
      margin-right: 10px;
      display: inline-block;
    }

    #controls>span:last-child>span {
      transform: rotate(90deg);
    }
  </style>

  <script>
    globalThis.console = globalThis.console || function (t) { };
  </script>

  <script>
    if (document.location.search.match(/type=embed/gi)) {
      window.parent.postMessage("resize", "*");
    }
  </script>
</head>

<body translate="no">
  <div id="game-container">
    <div id="game">
      <div id="road">
        <div id="cloud"></div>
        <div id="hero"></div>
      </div>

      <div id="hud">
        <span id="time" class="topUI">0</span>
        <span id="score" class="topUI">0</span>
        <span id="lap" class="topUI">0'00"000</span>
        <span id="tacho">0</span>
      </div>

      <div id="home">
        <h1>Dash</h1>
        <p id="text"></p>

        <div id="highscore"></div>
      </div>
    </div>
  </div>
  </div>

  <div id="controls">
    <span><span>C</span>insert coin</span>
    <span><span>M</span>mute</span>
    <span><span>&lt;</span><span>&gt;</span>move</span>
    <span><span>&lt;</span><span>&gt;</span>accelerate</span>
  </div>
  <script src="javascript/1.js"></script>

  <script id="rendered-js">
    // ------------------------------------------------------------
    // assets
    // ------------------------------------------------------------

    const ASSETS = {
      COLOR: {
        TAR: ["#959298", "#9c9a9d"],
        RUMBLE: ["#959298", "#f5f2f6"],
        GRASS: ["#eedccd", "#e6d4c5"],
      },

      IMAGE: {
        TREE: {
          src: "images/tree.png",
          width: 132,
          height: 192,
        },

        HERO: {
          src: "images/hero.png",
          width: 110,
          height: 56,
        },

        CAR: {
          src: "images/car04.png",
          width: 50,
          height: 36,
        },

        FINISH: {
          src: "images/finish.png",
          width: 339,
          height: 180,
          offset: -0.5,
        },

        SKY: {
          src: "images/cloud.jpg",
        },
      },

      AUDIO: {
        theme:
          "https://s3-us-west-2.amazonaws.com/s.cdpn.io/155629/theme.mp3",
        engine:
          "https://s3-us-west-2.amazonaws.com/s.cdpn.io/155629/engine.wav",
        honk: "https://s3-us-west-2.amazonaws.com/s.cdpn.io/155629/honk.wav",
        beep: "https://s3-us-west-2.amazonaws.com/s.cdpn.io/155629/beep.wav",
      },
    };

    // ------------------------------------------------------------
    // helper functions
    // ------------------------------------------------------------

    function pad(n, numZeros, char = 0) {
      let num = Math.abs(n);
      let zeros = Math.max(0, numZeros - Math.floor(num).toString().length);
      let zeroString = Math.pow(10, zeros)
        .toString()
        .substr(1)
        .replace(0, char);
      return zeroString + num;
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(v, max));
    }

    const timestamp = (_) => Date.now();
    const accelerate = (v, accel, dt) => v + accel * dt;
    const isCollide = (x1, w1, x2, w2) => (x1 - x2) ** 2 <= (w2 + w1) ** 2;

    function getRand(min, max) {
      return Math.trunc(Math.random() * (max - min) + min);
    }

    function randomProperty(obj) {
      let keys = Object.keys(obj);
      return obj[keys[Math.trunc(keys.length * Math.random())]];
    }

    function drawQuad(element, layer, color, points) {
      const { x1, y1, w1, x2, y2, w2 } = points;
      element.style.zIndex = layer;
      element.style.background = color;
      element.style.top = y2 + `px`;
      element.style.left = x1 - w1 / 2 - w1 + `px`;
      element.style.width = w1 * 3 + `px`;
      element.style.height = y1 - y2 + `px`;

      let leftOffset = w1 + x2 - x1 + Math.abs(w2 / 2 - w1 / 2);
      element.style.clipPath = `polygon(${leftOffset}px 0, ${leftOffset + w2
        }px 0, 66.66% 100%, 33.33% 100%)`;
    }

    const KEYS = {};
    const keyUpdate = (e) => {
      KEYS[e.code] = e.type === `keydown`;
      e.preventDefault();
    };
    addEventListener(`keydown`, keyUpdate);
    addEventListener(`keyup`, keyUpdate);

    function sleep(ms) {
      return new Promise(function (resolve, reject) {
        setTimeout((_) => resolve(), ms);
      });
    }

    // ------------------------------------------------------------
    // objects
    // ------------------------------------------------------------

    class Line {
      x = 0;
      y = 0;
      z = 0;
      X = 0;
      Y = 0;
      W = 0;
      curve = 0;
      scale = 0;
      elements = [];
      special = null;

      project(camX, camY, camZ) {
        this.scale = camD / (this.z - camZ);
        this.X = (1 + this.scale * (this.x - camX)) * halfWidth;
        this.Y = Math.ceil(((1 - this.scale * (this.y - camY)) * height) / 2);
        this.W = this.scale * roadW * halfWidth;
      }

      clearSprites() {
        for (let e of this.elements) e.style.background = "transparent";
      }

      drawSprite(depth, layer, sprite, offset) {
        let destX = this.X + this.scale * halfWidth * offset;
        let destY = this.Y + 4;
        let destW = (sprite.width * this.W) / 265;
        let destH = (sprite.height * this.W) / 265;

        destX += destW * offset;
        destY += destH * -1;

        let obj = layer instanceof Element ? layer : this.elements[layer + 6];
        obj.style.background = `url('${sprite.src}') no-repeat`;
        obj.style.backgroundSize = `${destW}px ${destH}px`;
        obj.style.left = destX + `px`;
        obj.style.top = destY + `px`;
        obj.style.width = destW + `px`;
        obj.style.height = destH + `px`;
        obj.style.zIndex = depth;
      }
    }

    class Car {
      constructor(pos, type, lane) {
        this.pos = pos;
        this.type = type;
        this.lane = lane;

        const element = document.createElement("div");
        road.appendChild(element);
        this.element = element;
      }

      remove() {
        this.element.remove();
      }
    }

    class Audio {
      constructor() {
        this.audioCtx = new AudioContext();

        // volume
        this.destination = this.audioCtx.createGain();
        this.volume = 1;
        this.destination.connect(this.audioCtx.destination);

        this.files = {};

        this.load(ASSETS.AUDIO.theme, "theme", (key) => {
          let source = this.audioCtx.createBufferSource();
          source.buffer = this.files[key];

          let gainNode = this.audioCtx.createGain();
          gainNode.gain.value = 0.6;
          source.connect(gainNode);
          gainNode.connect(this.destination);

          source.loop = true;
          source.start(0);
        });
      }

      get volume() {
        return this.destination.gain.value;
      }

      set volume(level) {
        this.destination.gain.value = level;
      }

      play(key, pitch) {
        if (this.files[key]) {
          let source = this.audioCtx.createBufferSource();
          source.buffer = this.files[key];
          source.connect(this.destination);
          if (pitch) source.detune.value = pitch;
          source.start(0);
        } else this.load(key, () => this.play(key));
      }

      load(src, key, callback) {
        let request = new XMLHttpRequest();
        request.open("GET", src, true);
        request.responseType = "arraybuffer";
        request.onload = () => {
          this.audioCtx.decodeAudioData(
            request.response,
            (beatportBuffer) => {
              this.files[key] = beatportBuffer;
              callback(key);
            },
            () => { }
          );
        };
        request.send();
      }
    }

    // ------------------------------------------------------------
    // global varriables
    // ------------------------------------------------------------

    const highscores = [];
    const ASSETS_COLOR_GRASS = ASSETS.COLOR.GRASS;
    const ASSETS_COLOR_RUMBLE = ASSETS.COLOR.RUMBLE;
    const ASSETS_COLOR_TAR = ASSETS.COLOR.TAR;

    globalThis.width = 1200;
    globalThis.halfWidth = globalThis.width / 2;
    globalThis.height = 700;
    const roadW = 4000;
    const segL = 200;
    const camD = 0.2;
    const H = 1500;
    const N = 70;

    const maxSpeed = 200;
    const accel = 38;
    const breaking = -80;
    const decel = -40;
    const maxOffSpeed = 40;
    const offDecel = -70;
    const enemy_speed = 8;
    const hitSpeed = 20;

    const LANE = {
      A: -2.3,
      B: -0.5,
      C: 1.2,
    };

    const mapLength = 15000;

    // loop
    let then = timestamp();
    const targetFrameRate = 1000 / 60; // in ms

    let audio;

    // game
    let inGame,
      start,
      playerX,
      speed,
      scoreVal,
      pos,
      cloudOffset,
      sectionProg,
      mapIndex,
      countDown;
    let lines = [];
    let cars = [];

    // ------------------------------------------------------------
    // map
    // ------------------------------------------------------------

    function getFun(val) {
      return (i) => val;
    }

    function genMap() {
      const map = [];
      let i = 0;

      while (i < mapLength) {
        const jump = getRand(0, 50);
        const sectionLength = getRand(300, 600);

        const section = {
          from: i + jump,
          to: i + jump + sectionLength,
        };

        i = section.to;

        const randHeight = getRand(-5, 5);
        const randCurve = getRand(5, 30) * (Math.random() >= 0.5 ? 1 : -1);
        const randInterval = getRand(20, 40);

        const r = Math.random();
        if (r > 0.9)
          Object.assign(section, {
            curve: () => randCurve,
            height: () => randHeight,
          });
        else if (r > 0.8)
          Object.assign(section, {
            curve: () => 0,
            height: (val) => Math.sin(val / randInterval) * 1000,
          });
        else if (r > 0.7)
          Object.assign(section, {
            curve: () => 0,
            height: () => randHeight,
          });
        else
          Object.assign(section, {
            curve: () => randCurve,
            height: () => 0,
          });

        map.push(section);
      }

      map.push({
        from: i,
        to: i + N,
        curve: () => 0,
        height: () => 0,
        special: ASSETS.IMAGE.FINISH,
      }, { from: Infinity });
      return map;
    }

    let map = genMap();

    // ------------------------------------------------------------
    // additional controls
    // ------------------------------------------------------------

    addEventListener(`keyup`, function (e) {
      if (e.code === "Semicolon") {
        e.preventDefault();

        audio.volume = audio.volume === 0 ? 1 : 0;
        return;
      }

      if (e.code === "KeyC") {
        e.preventDefault();

        if (inGame) return;

        sleep(0)
          .then((_) => {
            text.classList.remove("blink");
            text.innerText = 3;
            audio.play("beep");
            return sleep(1000);
          })
          .then((_) => {
            text.innerText = 2;
            audio.play("beep");
            return sleep(1000);
          })
          .then((_) => {
            reset();

            home.style.display = "none";

            road.style.opacity = 1;
            hero.style.display = "block";
            hud.style.display = "block";

            audio.play("beep", 500);

            inGame = true;
          });

        return;
      }

      if (e.code === "Escape") {
        e.preventDefault();

        reset();
      }
    });

    function handleInput(step) {
      playerX -= (lines[Math.trunc(pos / segL)].curve / 5000) * step * speed;

      if (KEYS.ArrowRight) {
        hero.style.backgroundPosition = "-220px 0";
        playerX += 0.007 * step * speed;
      } else if (KEYS.ArrowLeft) {
        hero.style.backgroundPosition = "0 0";
        playerX -= 0.007 * step * speed;
      } else {
        hero.style.backgroundPosition = "-110px 0";
      }

      playerX = clamp(playerX, -3, 3);
    }

    function updateUI(step, startPos) {
      if (!inGame) {
        speed = clamp(accelerate(speed, breaking, step), 0, maxSpeed);
      } else if (countDown <= 0 || lines[startPos].special) {
        tacho.style.display = "none";
        home.style.display = "block";
        road.style.opacity = 0.4;
        text.innerText = "INSERT COIN";

        highscores.push(lap.innerText);
        highscores.sort();
        updateHighscore();
        inGame = false;
      } else {
        time.innerText = pad(Math.trunc(countDown), 3);
        score.innerText = pad(Math.trunc(scoreVal), 8);
        tacho.innerText = Math.trunc(speed);

        const cT = new Date(timestamp() - start);
        lap.innerText = `${cT.getMinutes()}'${pad(cT.getSeconds(), 2)}"${pad(cT.getMilliseconds(), 3)}`;
      }

      cloudOffset -= lines[startPos].curve * step * speed * 0.13;
      cloud.style.backgroundPosition = `${Math.trunc(cloudOffset)}px 0`;
    }

    function updateEnemies(step, startPos, endPos) {
      for (const car of cars) {
        car.pos = (car.pos + enemy_speed * step) % N;
        if (Math.trunc(car.pos) === endPos) {
          car.pos = (speed < 30) ? startPos : endPos - 2;
          car.lane = randomProperty(LANE);
        }
        const offsetRatio = 5;
        if (Math.trunc(car.pos) === startPos && isCollide(playerX * offsetRatio + LANE.B, 0.5, car.lane, 0.5)) {
          speed = Math.min(hitSpeed, speed);
          if (inGame) audio.play("honk");
        }
      }
    }

    function renderRoad(startPos) {
      let maxy = height;
      const camH = H + lines[startPos].y;
      let x = 0;
      let dx = 0;

      for (let n = startPos; n < startPos + N; n++) {
        const l = lines[n % N];
        const level = N * 2 - n;
        l.project(playerX * roadW - x, camH, startPos * segL - (n >= N ? N * segL : 0));
        x += dx;
        dx += l.curve;

        l.clearSprites();
        drawAssets(l, n, level);

        if (l.Y >= maxy) continue;
        maxy = l.Y;
        drawSegment(l, level, Math.trunc(n / 2) % 2, lines[(n - 1) % N]);
      }
    }

    function drawAssets(l, n, level) {
      if (n % 10 === 0) l.drawSprite(level, 0, ASSETS.IMAGE.TREE, -2);
      if ((n + 5) % 10 === 0) l.drawSprite(level, 0, ASSETS.IMAGE.TREE, 1.3);
      if (l.special) l.drawSprite(level, 0, l.special, l.special.offset || 0);

      for (const car of cars) {
        if (Math.trunc(car.pos) === n % N) l.drawSprite(level, car.element, car.type, car.lane);
      }
    }

    function drawSegment(l, level, even, p) {
      const grass = ASSETS_COLOR_GRASS[even];
      const rumble = ASSETS_COLOR_RUMBLE[even];
      const tar = ASSETS_COLOR_TAR[even];

      drawQuad(l.elements[0], level, grass, { x1: width / 4, y1: p.Y, w1: halfWidth + 2, x2: width / 4, y2: l.Y, w2: halfWidth });
      drawQuad(l.elements[1], level, grass, { x1: (width / 4) * 3, y1: p.Y, w1: halfWidth + 2, x2: (width / 4) * 3, y2: l.Y, w2: halfWidth });
      drawQuad(l.elements[2], level, rumble, { x1: p.X, y1: p.Y, w1: p.W * 1.15, x2: l.X, y2: l.Y, w2: l.W * 1.15 });
      drawQuad(l.elements[3], level, tar, { x1: p.X, y1: p.Y, w1: p.W, x2: l.X, y2: l.Y, w2: l.W });

      if (!even) {
        drawQuad(l.elements[4], level, ASSETS.COLOR.RUMBLE[1], { x1: p.X, y1: p.Y, w1: p.W * 0.4, x2: l.X, y2: l.Y, w2: l.W * 0.4 });
        drawQuad(l.elements[5], level, tar, { x1: p.X, y1: p.Y, w1: p.W * 0.35, x2: l.X, y2: l.Y, w2: l.W * 0.35 });
      }
    }

    function update(step) {
      pos += speed;
      while (pos >= N * segL) pos -= N * segL;
      while (pos < 0) pos += N * segL;

      const startPos = Math.trunc(pos / segL);
      const endPos = (startPos + N - 1) % N;

      scoreVal += speed * step;
      countDown -= step;

      handleInput(step);

      if (inGame && KEYS.ArrowUp) speed = accelerate(speed, accel, step);
      else if (KEYS.ArrowDown) speed = accelerate(speed, breaking, step);
      else speed = accelerate(speed, decel, step);

      if (Math.abs(playerX) > 0.55 && speed >= maxOffSpeed) speed = accelerate(speed, offDecel, step);
      speed = clamp(speed, 0, maxSpeed);

      const current = map[mapIndex];
      const use = (current && current.from < scoreVal && current.to > scoreVal);
      if (use) sectionProg += speed * step;
      lines[endPos].curve = use ? current.curve(sectionProg) : 0;
      lines[endPos].y = use ? current.height(sectionProg) : 0;
      lines[endPos].special = null;

      if (current && current.to <= scoreVal) {
        mapIndex++;
        sectionProg = 0;
        lines[endPos].special = (map[mapIndex] && map[mapIndex].special) || null;
      }

      updateUI(step, startPos);
      updateEnemies(step, startPos, endPos);
      renderRoad(startPos);
    }

    // ------------------------------------------------------------
    // init
    // ------------------------------------------------------------

    function reset() {
      inGame = false;

      start = timestamp();
      countDown = map[map.length - 2].to / 130 + 10;

      playerX = 0;
      speed = 0;
      scoreVal = 0;

      pos = 0;
      cloudOffset = 0;
      sectionProg = 0;
      mapIndex = 0;

      for (let line of lines) line.curve = line.y = 0;

      text.innerText = "INSERT COIN";
      text.classList.add("blink");

      road.style.opacity = 0.4;
      hud.style.display = "none";
      home.style.display = "block";
      tacho.style.display = "block";
    }

    function updateHighscore() {
      let hN = Math.min(12, highscores.length);
      for (let i = 0; i < hN; i++) {
        highscore.children[i].innerHTML = `${(i + 1).pad(2, "&nbsp;")}. ${highscores[i]
          }`;
      }
    }

    function init() {

      hero.style.top = globalThis.height - 80 + "px";
      hero.style.left = globalThis.halfWidth - ASSETS.IMAGE.HERO.width / 2 + "px";
      hero.style.background = `url(${ASSETS.IMAGE.HERO.src})`;
      hero.style.width = `${ASSETS.IMAGE.HERO.width}px`;
      hero.style.height = `${ASSETS.IMAGE.HERO.height}px`;

      cloud.style.backgroundImage = `url(${ASSETS.IMAGE.SKY.src})`;

      audio = new Audio();
      Object.keys(ASSETS.AUDIO).forEach((key) =>
        audio.load(ASSETS.AUDIO[key], key, (_) => 0)
      );

      cars.push(
        new Car(0, ASSETS.IMAGE.CAR, LANE.C),
        new Car(10, ASSETS.IMAGE.CAR, LANE.B),
        new Car(20, ASSETS.IMAGE.CAR, LANE.C),
        new Car(35, ASSETS.IMAGE.CAR, LANE.C),
        new Car(50, ASSETS.IMAGE.CAR, LANE.A),
        new Car(60, ASSETS.IMAGE.CAR, LANE.B),
        new Car(70, ASSETS.IMAGE.CAR, LANE.A)
      );

      for (let i = 0; i < N; i++) {
        const l = new Line();
        l.z = i * segL + 270;

        for (let j = 0; j < 6 + 2; j++) {
          const element = document.createElement("div");
          road.appendChild(element);
          l.elements.push(element);
        }

        lines.push(l);
      }

      for (let i = 0; i < 12; i++) {
        const element = document.createElement("p");
        highscore.appendChild(element);
      }
      updateHighscore();

      reset();

      // START GAME LOOP
      (function loop() {
        requestAnimationFrame(loop);

        let now = timestamp();
        let delta = now - then;

        if (delta > targetFrameRate) {
          then = now - (delta % targetFrameRate);
          update(delta / 1000);
        }
      })();
    }

    init();
    //# sourceURL=pen.js

  </script>
  <style>
    #game:fullscreen {
      width: 100vw !important;
      height: 100vh !important;
      margin: 0 !important;
    }
  </style>
  <script src="javascript/fullscreen.js"></script>
  <script src="javascript/null.js"></script>
</body>

</html>